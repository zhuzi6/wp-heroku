{"version":3,"file":"934.js","mappings":"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","sources":["webpack://sakurairo-scripts/./node_modules/promise-worker/register.js","webpack://sakurairo-scripts/webpack/bootstrap","webpack://sakurairo-scripts/webpack/runtime/compat get default export","webpack://sakurairo-scripts/webpack/runtime/define property getters","webpack://sakurairo-scripts/webpack/runtime/hasOwnProperty shorthand","webpack://sakurairo-scripts/./node_modules/palette/dist/util.js","webpack://sakurairo-scripts/./node_modules/palette/dist/kmeans.js","webpack://sakurairo-scripts/./src/sakura-app/theme-color/worker.ts"],"sourcesContent":["'use strict'\n\nfunction isPromise (obj) {\n  // via https://unpkg.com/is-promise@2.1.0/index.js\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n}\n\nfunction registerPromiseWorker (callback) {\n  function postOutgoingMessage (e, messageId, error, result) {\n    function postMessage (msg) {\n      /* istanbul ignore if */\n      if (typeof self.postMessage !== 'function') { // service worker\n        e.ports[0].postMessage(msg)\n      } else { // web worker\n        self.postMessage(msg)\n      }\n    }\n    if (error) {\n      /* istanbul ignore else */\n      if (typeof console !== 'undefined' && 'error' in console) {\n        // This is to make errors easier to debug. I think it's important\n        // enough to just leave here without giving the user an option\n        // to silence it.\n        console.error('Worker caught an error:', error)\n      }\n      postMessage([messageId, {\n        message: error.message\n      }])\n    } else {\n      postMessage([messageId, null, result])\n    }\n  }\n\n  function tryCatchFunc (callback, message) {\n    try {\n      return { res: callback(message) }\n    } catch (e) {\n      return { err: e }\n    }\n  }\n\n  function handleIncomingMessage (e, callback, messageId, message) {\n    var result = tryCatchFunc(callback, message)\n\n    if (result.err) {\n      postOutgoingMessage(e, messageId, result.err)\n    } else if (!isPromise(result.res)) {\n      postOutgoingMessage(e, messageId, null, result.res)\n    } else {\n      result.res.then(function (finalResult) {\n        postOutgoingMessage(e, messageId, null, finalResult)\n      }, function (finalError) {\n        postOutgoingMessage(e, messageId, finalError)\n      })\n    }\n  }\n\n  function onIncomingMessage (e) {\n    var payload = e.data\n    if (!Array.isArray(payload) || payload.length !== 2) {\n      // message doens't match communication format; ignore\n      return\n    }\n    var messageId = payload[0]\n    var message = payload[1]\n\n    if (typeof callback !== 'function') {\n      postOutgoingMessage(e, messageId, new Error(\n        'Please pass a function into register().'))\n    } else {\n      handleIncomingMessage(e, callback, messageId, message)\n    }\n  }\n\n  self.addEventListener('message', onIncomingMessage)\n}\n\nmodule.exports = registerPromiseWorker\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function awaitImage(imgElement) {\n    return new Promise((resolve, reject) => {\n        imgElement.addEventListener('load', () => {\n            resolve();\n        });\n        imgElement.addEventListener('error', () => {\n            reject();\n        });\n    });\n}\nexport function readImage(imgSource) {\n    return _readImage(_prepare2DContext, imgSource);\n}\nexport function readImageAsync(imgSource) {\n    return _readImage(_prepare2DContextAsync, imgSource);\n}\nfunction _readImage(prepareCtx, imgSource) {\n    const { naturalWidth, naturalHeight } = imgSource;\n    const ctx = prepareCtx(naturalWidth, naturalHeight);\n    ctx?.drawImage(imgSource, 0, 0, naturalWidth, naturalHeight);\n    return ctx?.getImageData(0, 0, naturalWidth, naturalHeight);\n}\n/**\n * 降采样后读取图片\n * @param imgSource\n * @param maxSample\n * @returns\n */\nexport function readImageDownsampling(imgSource, maxSample) {\n    return _readImageDownsampling(_prepare2DContext, imgSource, maxSample);\n}\nexport function readImageDownsamplingAsync(imgSource, maxSample) {\n    return _readImageDownsampling(_prepare2DContextAsync, imgSource, maxSample);\n}\nfunction _readImageDownsampling(prepareCtx, imgSource, maxSample) {\n    const { naturalWidth: width, naturalHeight: height } = imgSource;\n    const scale = width * height / maxSample;\n    if (scale > 1) {\n        const n_width = width / Math.sqrt(scale);\n        const n_height = height / Math.sqrt(scale);\n        const ctx = prepareCtx(n_width, n_height);\n        ctx?.drawImage(imgSource, 0, 0, n_width, n_height);\n        return ctx?.getImageData(0, 0, n_width, n_height);\n    }\n    else {\n        const ctx = prepareCtx(width, height);\n        ctx?.drawImage(imgSource, 0, 0);\n        return ctx?.getImageData(0, 0, width, height);\n    }\n}\nfunction _prepare2DContext(width, height) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.height = height;\n    canvas.width = width;\n    return ctx;\n}\n/**\n * Use OffscreenCanvas\n */\nfunction _prepare2DContextAsync(width, height) {\n    const canvas = new OffscreenCanvas(width, height);\n    const ctx = canvas.getContext('2d');\n    return ctx;\n}\n/**\n * 从@type {Uint8ClampedArray} 中读取，每四个元素合并到一个数组元素中\n * @param img 要处理的图像矩阵\n * @returns\n */\nexport function toPixel(img) {\n    const { data } = img;\n    const array = new Array(data.length / 4);\n    for (let i = 0; i < data.length; i += 4) {\n        array[i / 4] = [data[i], data[i + 1], data[i + 2], data[i + 3]];\n    }\n    return array;\n}\n/**\n * 返回两个四维坐标间的欧几里得距离\n * @param a\n * @param b\n * @returns\n */\nexport function euclidean_distance(a, b) {\n    const r = a[0] - b[0];\n    const g = a[1] - b[1];\n    const _b = a[2] - b[2];\n    const _a = a[3] - b[3];\n    return Math.sqrt(r * r\n        + g * g\n        + _b * _b\n        + _a * _a);\n    /* return Math.sqrt(\n        Math.pow(a[0] - b[0], 2)\n        + Math.pow(a[1] - b[1], 2)\n        + Math.pow(a[2] - b[2], 2)\n        + Math.pow(a[3] - b[3], 2)\n    ) */\n}\n/**\n * 以数组形式返回三个数字中的最大值与最小值\n * @param param0 一个包含三个数字的数组\n * @returns [max,min]\n */\nfunction max_min_of_three([a, b, c]) {\n    if (a > b) {\n        if (b > c) {\n            //abc\n            return [a, c];\n        }\n        else {\n            if (a > c) {\n                //acb\n                return [a, b];\n            }\n            else {\n                //cab\n                return [c, b];\n            }\n        }\n    }\n    else {\n        //a<b\n        if (b > c) {\n            if (c > a) {\n                //bca\n                return [b, a];\n            }\n            else {\n                //bac\n                return [b, c];\n            }\n        }\n        else {\n            //cba\n            return [c, a];\n        }\n    }\n}\nexport function normalizeRGBA(rgba) {\n    //@ts-ignore\n    return rgba.map(v => v / 255);\n}\nexport function rgbaToHSLA(rgba) {\n    let h, s;\n    //@ts-ignore\n    const [max, min] = max_min_of_three(rgba);\n    const diff = max - min;\n    const light_2x = max + min;\n    //h\n    if (diff == 0) {\n        h = 0;\n        s = 0;\n    }\n    else {\n        if (max == rgba[0]) {\n            const temp_h = 60 * (rgba[1] - rgba[2]) / diff;\n            if (temp_h < 0) {\n                h = temp_h + 360;\n            }\n            else {\n                h = temp_h;\n            }\n        }\n        else if (max == rgba[1]) {\n            h = 60 * (rgba[2] - rgba[0]) / diff + 120;\n        }\n        else {\n            h = 60 * (rgba[0] - rgba[1]) / diff + 240;\n        }\n        if (light_2x == 0) {\n            s = 0;\n        }\n        else if (light_2x <= 1) {\n            s = diff / light_2x;\n        }\n        else {\n            s = diff / (2 - light_2x);\n        }\n    }\n    return [h, s, light_2x / 2, rgba[3]];\n}\nfunction adjustAngleIn2Pi(angle) {\n    if (angle < 0)\n        return angle + 360;\n    let temp = angle;\n    while (temp >= 360) {\n        temp = angle - 360;\n    }\n    return temp;\n}\nexport const sortHSL = (sort = [0, 1, 2, 3]) => (a, b) => {\n    let result;\n    for (const s of sort) {\n        result = a[s] - b[s];\n        if (result != 0) {\n            return result;\n        }\n    }\n    //其实是赋了值的，但是ts没猜出来\n    //@ts-ignore\n    return result;\n};\nexport const hslaCSSText = ([h, s, l, a]) => `hsla(${h}deg,${s * 100}%,${l * 100}%,${a})`;\nexport const rgbaCSSText = (pixel) => `rgba(${pixel.map(v => Math.floor(v)).join(',')})`;\n/* export class RGBAArray extends Uint8ClampedArray {\n    pixel(pixel_index: number) {\n        return [pixel_index * 4, pixel_index * 4 + 1, pixel_index * 4 + 2, pixel_index * 4 + 3]\n    }\n    r(pixel_index: number) {\n        return pixel_index * 4\n    }\n    g(pixel_index: number) {\n        return pixel_index * 4 + 1\n    }\n    b(pixel_index: number) {\n        return pixel_index * 4 + 2\n    }\n    a(pixel_index: number) {\n        return pixel_index * 4 + 3\n    }\n} */ \n","import { euclidean_distance } from \"./util\";\nexport default function kmeans(data, k, attempt) {\n    const THRESOLD = 1;\n    const cluster_centers = new Array(k);\n    const new_cluster_centers = new Array(k);\n    //随机选点\n    for (let i = 0; i < k; i++) {\n        cluster_centers[i] = data[Math.floor(Math.random() * data.length)];\n    }\n    let iterate_time = 0;\n    const cluster_sum = new Array(k).fill(0).map(() => new Array(5).fill(0)); //[r,g,b,a,c]\n    while (iterate_time < attempt) {\n        //准备坐标和\n        //计算每个点与中心的距离\n        for (let i = 0; i < data.length; i++) {\n            const data_item = data[i];\n            let cluster_index = 0;\n            let _min_distance = euclidean_distance(data_item, cluster_centers[0]);\n            for (let j = 1; j < k; j++) {\n                const distance = euclidean_distance(data_item, cluster_centers[j]);\n                if (distance < _min_distance) {\n                    _min_distance = distance;\n                    cluster_index = j;\n                }\n            }\n            const sum = cluster_sum[cluster_index];\n            sum[0] += data_item[0];\n            sum[1] += data_item[1];\n            sum[2] += data_item[2];\n            sum[3] += data_item[3];\n            sum[4]++;\n        }\n        //重新计算中心点\n        for (let i = 0; i < k; i++) {\n            const rgbac = cluster_sum[i];\n            const count = rgbac[4];\n            if (count == 0)\n                new_cluster_centers[i] = data[Math.floor(Math.random() * data.length)];\n            else {\n                new_cluster_centers[i] = [rgbac[0] / count, rgbac[1] / count, rgbac[2] / count, rgbac[3] / count];\n            }\n        }\n        let diff = 0;\n        for (let i = 0; i < k; i++) {\n            diff += euclidean_distance(cluster_centers[i], new_cluster_centers[i]);\n        }\n        if (diff <= THRESOLD) {\n            return {\n                cluster_center: new_cluster_centers, iterate_time, fit_thresold: true, label: cluster_sum.map(v => v[4]), size: data.length\n            };\n        }\n        _swap_array(new_cluster_centers, cluster_centers);\n        iterate_time++;\n        //清空累加\n        for (let i = 0; i < k; i++) {\n            for (let j = 0; j < 5; j++) {\n                cluster_sum[i][j] = 0;\n            }\n        }\n    }\n    return {\n        cluster_center: cluster_centers, iterate_time, fit_thresold: false, label: cluster_sum.map(v => v[4]), size: data.length\n    };\n}\nfunction _swap_array(from, to) {\n    for (let i = 0; i < from.length; i++) {\n        to[i] = from[i];\n    }\n}\n","import { kmeans, toPixel } from \"palette\";\nimport registerPromiseWorker from 'promise-worker/register';\nregisterPromiseWorker(function (data) {\n    const { img, k, iteration } = data;\n    const result = kmeans(toPixel(img), k, iteration);\n    return result;\n});\n"],"names":["module","exports","callback","postOutgoingMessage","e","messageId","error","result","postMessage","msg","self","ports","console","message","addEventListener","payload","data","Array","isArray","length","Error","obj","res","err","tryCatchFunc","then","finalResult","finalError","handleIncomingMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","prop","prototype","hasOwnProperty","call","euclidean_distance","b","r","g","_b","_a","Math","sqrt","_swap_array","from","to","i","img","k","iteration","attempt","cluster_centers","new_cluster_centers","floor","random","iterate_time","cluster_sum","fill","map","data_item","cluster_index","_min_distance","j","distance","sum","rgbac","count","diff","cluster_center","fit_thresold","label","v","size","kmeans","array","toPixel"],"sourceRoot":""}